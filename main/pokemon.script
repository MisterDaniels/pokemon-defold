local util_module = require 'main/util'
local cursor = require 'in.cursor'

function init(self)
	self.moving = false
	self.is_attacking = false
	
	self.input = vmath.vector3()
	self.dir = vmath.vector3(0, 1, 0)

	go.property('owner', hash('pokemon_owner'))
	go.property('go', hash('pokemon_go'))
	go.property('name', hash('pokemon_name'))
	go.property('time_between_attack', 3)
	go.property('damage', 20)
	go.property('life', 100)

	pokemon_name = util_module.convert_hash_to_string(self.go)
	local pokemon_instance_sprite = msg.url(nil, go.get_id(), 'pokemon_sprite')
	msg.post(pokemon_instance_sprite, 'play_animation', { id = hash(pokemon_name .. '_walk_down') })

	pprint(go.get_position())
end

function on_message(self, message_id, message, sender)
	pokemon_name = util_module.convert_hash_to_string(self.go)
	
	if message_id == hash('follow') then
		util_module.change_animation_by_direction('#pokemon_sprite', message.direction, pokemon_name)

		if message.position == hash('go_back') then
			go.set_position(self.last_pos)
			return
		end

		self.last_pos = go.get_position()
		go.set_position(message.position)
	end

	if message_id == hash('trigger_response') then
		pprint(message_id)
		if message.enter then
			if sender == msg.url('#collision_range') then
				print('spotted')

				if self.is_attacking == false then
					if self.owner == hash('nature') and message.group == hash('player') then
						self.attack_timer = timer.delay(self.time_between_attack, true, function()
							local random_damage = util_module.get_random_number_between(0, self.damage)
							local character_pokemon = go.get(util_module.convert_hash_to_string(message.other_id) .. '#player', 'pokemon_instance')

							if character_pokemon then
								msg.post(character_pokemon, 'deal_damage', { damage = random_damage })
							else
								msg.post(message.other_id, 'deal_damage', { damage = random_damage })
							end
						end)
					pprint(message.group)
					elseif self.owner == hash('player') and message.group == hash('range') then
						pprint('pokemon player attacking')
						self.attack_timer = timer.delay(self.time_between_attack, true, function()
							local random_damage = util_module.get_random_number_between(0, self.damage)

							msg.post(message.other_id, 'deal_damage', { damage = random_damage })
						end) 
					end

					self.is_attacking = false
				end
			end
		else
			if sender == msg.url('#collision_range') then
				print('unspotted')

				timer.cancel(self.attack_timer)
				self.is_attacking = false
			end
		end
	end

	if message_id == hash('deal_damage') then
		if message.damage then
			if (self.life - message.damage) <= 0 then
				go.delete()
				self.life = 0

				if self.owner == hash('player') then
					go.set('/player#player', 'pokemon_instance', false)
				end
			else 
				self.life = self.life - message.damage
			end

			local target = 'target_pokemon_life'
			if self.owner == hash('player') then
				target = 'player_pokemon_life'
			end

			msg.post('/ui#main', 'change_life', {
				target = target,
				life = self.life
			})

			local pos = new vmath.vector3(go.get_position().x, go.get_position().y, 0.1)
			factory.create('/game#blood', pos, nil, {}, 1)
		else
			print('miss')
		end
	end

	if message_id == hash('stop_attacking') then
		timer.cancel(self.attack_timer)
		self.is_attacking = false
	end

	if message_id == cursor.CLICKED then
		pprint('clicked')
	end

	if message_id == cursor.OVER then
		pprint('over')
		pprint(go.get_position('#collision'))
		pprint(go.get_position())
	end
end